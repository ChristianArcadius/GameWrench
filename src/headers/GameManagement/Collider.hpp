#pragma once

#include "SpriteCollection.hpp"

namespace gw {

class Collider
{
public:

    enum DetectionMethod {
        // Axis-aligned bounding box
        AABB
    };

///////////////////////////////////////////////////////////////////////////////////////////////////
// Constructors 
///////////////////////////////////////////////////////////////////////////////////////////////////

    Collider(DetectionMethod collisionType = AABB);

	virtual ~Collider() = default;

///////////////////////////////////////////////////////////////////////////////////////////////////
// Mutators 
///////////////////////////////////////////////////////////////////////////////////////////////////

    Collider& applyCollision(Sprite& sprite);
    Collider& applyCollision(SpriteCollection& sprite);
    Collider& canCollideWith(Sprite& sprite);
    Collider& canCollideWith(SpriteCollection& sprite);

///////////////////////////////////////////////////////////////////////////////////////////////////
// Collision Methods 
///////////////////////////////////////////////////////////////////////////////////////////////////

	/// Returns number of pixels in which sprite1 is colliding with sprite2 using AABB collision
    static gw::Vector2f axisAlignedBoxCollision(gw::Sprite sprite1, gw::Sprite sprite2);

private:

///////////////////////////////////////////////////////////////////////////////////////////////////
// Private Members 
///////////////////////////////////////////////////////////////////////////////////////////////////

    SpriteCollection sprites;       // Sprites to check for collision
    SpriteCollection collidables;   // Sprites to check if sprites are colliding with

	// What to do when two objects collide
	std::function<void(Sprite& sprite, Sprite& collidedWith, Vector2f collision)>handleCollision;
};

} // namespace gw